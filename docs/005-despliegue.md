# Parte 5 - Deployment: Azure 

En la pr치ctica de laboratorio anterior, se utiliza GitHub Actions para empaquetar una aplicaci칩n en una imagen de Docker y publicar ese paquete en el registro de GitHub Container. El siguiente paso en un proceso cl치sico de entrega continua es el **deploy** la aplicaci칩n.

En esta pr치ctica de laboratorio, ampliar치 el flujo de trabajo para implementar la imagen del contenedor en [Azure Web Apps](https://azure.microsoft.com/en-us/products/app-service/web), un servicio de aplicaci칩n web administrado en Azure que tambi칠n admite la implementaci칩n de contenedores.

Aprender치 c칩mo autenticarse f치cilmente en Azure mediante una acci칩n, utilizar variables de acciones para definir valores de configuraci칩n para sus acciones y establecer aprobaciones de implementaci칩n manuales para sus entornos.


## 1 - Variables de acciones y secretos

### 1 Crear una nueva variable de Acciones

Ya ha aprendido a utilizar variables dentro de un flujo de trabajo. Sin embargo, hasta ahora, solo ha utilizado variables proporcionadas por el propio GitHub. Ahora, aprendamos c칩mo agregar sus propias variables (y secretos) para definir configuraciones espec칤ficas del repositorio y otros valores que quiz치s no desee codificar en sus archivos de flujo de trabajo.


1.1. Asigne un nombre a la variable `AZ_APP_NAME`y proporcione un valor de su elecci칩n, preferiblemente el nombre de su repositorio (dado que el nombre de la aplicaci칩n debe ser 칰nico en todos los servicios web de Azure, elija algo distintivo). Haga clic en Agregar variable una vez terminado.
    ![Create a new variable](./images/005/issue-ops-007-create-az-app-name.png)

Ahora, ha creado una variable a la que se podr치 acceder desde todos los flujos de trabajo dentro de este repositorio como ${{ vars.APP_NAME }}. Haremos uso de esto en nuestro flujo de trabajo de implementaci칩n.




## 2- ampl칤e el flujo de trabajo para implementarlo en la etapa de preparaci칩n

Es hora de poner todo en acci칩n con un despliegue real. En laboratorios anteriores, cre칩 la aplicaci칩n y la empaquet칩 en una imagen de contenedor, que luego se public칩 en el registro de GitHub Container. Para iniciar la aplicaci칩n, debe ejecutar esta imagen de contenedor. Existen varios m칠todos para lograr esto, como a trav칠s de Azure Container Instances, Azure Web Apps para Linux o dentro de un cl칰ster de Kubernetes como Azure Kubernetes Services (AKS). Adem치s, Azure ofrece un servicio de aplicaci칩n web administrado conocido como Azure Web Apps, capaz de ejecutar instancias de contenedor. Para este taller, implementar치 la imagen del contenedor en Azure Web Apps.

Una de las mejores pr치cticas recomendadas para las implementaciones implica definir recursos mediante c칩digo (Infraestructura como c칩digo o IaC). Este proyecto viene equipado con scripts [Bicep](https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep) scripts que detallan toda la infraestructura. Sin embargo, tambi칠n se pueden utilizar alternativas como Terraform para ese fin.

### 2.1 Utilizaci칩n de infraestructura como c칩digo (IaC)

Los archivos de Bicep para la implementaci칩n se encuentran en la carpeta [`/infra/web-app`](../infra/web-app/) del repositorio, que consta de dos archivos distintos:

| Archivo            | Descripci칩n                                                                                                                   |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `main.bicep`    |El archivo de infraestructura principal, que crea un grupo de recursos de Azure e invoca los dem치s archivos para crear el entorno completo. |
| `web-app.bicep` | Especifica la aplicaci칩n en s칤, como una aplicaci칩n web para contenedores.                                                                          |

Para configurar los servicios de infraestructura necesarios e implementar la aplicaci칩n, utilizar치 la interfaz de l칤nea de comandos de Azure (`az cli`). Pronto integrar치 este paso en el flujo de trabajo. Sin embargo, antes de eso, es esencial que el paquete sea de acceso p칰blico.

### 2.2 Publicar el paquete

Si bien generalmente no se recomienda hacer p칰blicas las im치genes de los contenedores (a menos que est칠 trabajando con c칩digo fuente abierto), lo har치 por la simplicidad de esta pr치ctica de laboratorio. En un escenario real, el paquete seguir칤a siendo privado y ser칤a necesario proporcionar a Azure las credenciales de registro necesarias para acceder a las im치genes del contenedor.

1. Dir칤gete a la p치gina principal de tu repositorio y haz clic en Paquetes . Busque el paquete correspondiente y 치bralo.

2. Haga clic en el bot칩n Configuraci칩n del paquete en la parte inferior derecha de la p치gina:

    ![Click on Package settings](images/005/package-settings-button.png)

3. Despl치cese hasta el final de la p치gina y haga clic en Cambiar visibilidad :

    ![Click change visibility](images/005/danger-zone.png)

4. Cambie la visibilidad a P칰blica , ingrese el nombre del repositorio y presione el bot칩n confirmar:

    ![Confirm your changes](images/005/change-visibility.png)

### 2.3 Agregar el paso de implementaci칩n al flujo de trabajo

Ahora es el momento de ajustar el flujo de trabajo, integrando la automatizaci칩n para la implementaci칩n de la aplicaci칩n.

Abre el `node.js.yml`.  Inmediatamente despu칠s del `package-and-publish` job,  inserte el siguiente trabajo:

```yml
  staging:
    name: Deploy to Staging
    needs: [package-and-publish]
    runs-on: ubuntu-latest
    ## Only deploy after merges to the main branch, not on every PR
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
    environment:
      name: staging
      url: "${{ steps.deploy.outputs.url }}"

    steps:
      - uses: actions/checkout@v2

      - name: Log in to Azure using credentials
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy resources
        uses: azure/arm-deploy@v1
        id: deploy
        with:
          scope: subscription
          region: westeurope
          deploymentName: ${{ vars.AZ_APP_NAME }}-deployment
          template: ./infra/web-app/main.bicep
          parameters: "containerImage=${{ needs.package-and-publish.outputs.container }} actor=${{ github.actor }} appName=aw-${{ vars.APP_NAME }} repository=${{ github.repository }}"
```

Finalmente, debe incluir un [`output`](https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs) en su `package-and-publish` job para recuperar el nombre de la imagen del contenedor del registro. Esto se utilizar치 durante la implementaci칩n de Azure para configurar el alojamiento del contenedor.

```yml
     runs-on: ubuntu-latest
     outputs:
       container: ${{ steps.meta.outputs.tags }}
```

<details>
<summary>Haga clic aqu칤 para ver c칩mo deber칤a verse el archivo de flujo de trabajo completo</summary>

```yml
name: Node.js CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  build:
    name: "Build and Test"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16.x
          cache: "npm"
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test
      - name: "Report Coverage"
        if: always()
        uses: davelosert/vitest-coverage-report-action@v2

  package-and-publish:
    needs:
      - build
    name: 游냡 Package & Publish
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      container: ${{ steps.meta.outputs.tags }}

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Sign in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          registry: ghcr.io

      - name: Generate docker metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=tag
            type=ref,event=pr
            type=sha,event=branch,prefix=,suffix=,format=short
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v2
        with:
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  staging:
    name: Deploy to Staging
    needs: [package-and-publish]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    environment:
      name: staging
      url: "${{ steps.deploy.outputs.url }}"

    steps:
      - uses: actions/checkout@v2

      - name: Log in to Azure using OIDC
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy resources
        uses: azure/arm-deploy@v1
        id: deploy
        with:
          scope: subscription
          region: westeurope
          deploymentName: ${{ vars.AZ_APP_NAME }}-deployment
          template: ./infra/main.bicep
          parameters: "containerImage=${{ needs.package-and-publish.outputs.container }} actor=${{ github.actor }} appName=aw-${{ vars.AZ_APP_NAME }} repository=${{ github.repository }}"
```

</details>

El nuevo trabajo realiza las siguientes tareas:

- Tiene como objetivo un entorno denominado `staging`. Este enfoque simplifica el proceso de comprender qu칠 se implementa y d칩nde. Tambi칠n proporciona un enlace directo al objetivo dentro de GitHub.
- Determina la URL del entorno examinando los resultados del step `Deploy resources`. Este paso lee el par치metro de salida del archivo Bicep.
- Comprueba el c칩digo para acceder a la infraestructura como archivos de c칩digo.
- Inicia sesi칩n en Azure utilizando los secretos proporcionados por su organizaci칩n.
- Invoca la  `azure/arm-deploy` acci칩n para implementar la aplicaci칩n en Azure. Esto se hace pasando la plantilla principal y los par치metros adicionales, incluido el  `appName` que proporcion칩 como variable de Acciones.

Confirme los cambios del archivo para activar la ejecuci칩n del flujo de trabajo.

### 2.4 Navegar al entorno de prueba

1. Una vez completada la ejecuci칩n del flujo de trabajo, deber칤a ver un v칤nculo en el trabajo Implementar en ensayo en el gr치fico de visualizaci칩n del flujo de trabajo:

    ![Deployment success](images/005/deploy-success.png)

2. Haga clic en el enlace para abrir la aplicaci칩n que se ejecuta en Azure.

    ![Running app](images/005/running-app.png)

## 3 - Configurar la aprobaci칩n requerida para el entorno de ensayo

Ahora que la implementaci칩n est치 funcionando, es posible que desee introducir un proceso de aprobaci칩n manual.

1. Navegue hasta la Configuraci칩n de su repositorio , luego haga clic en Entornos y luego seleccione preparaci칩n :

    ![Configure staging](images/005/click-env.png)

2. Aseg칰rese de que la opci칩n Revisores requeridos est칠 seleccionada y agr칠guese como revisor.
3. Haga clic en Guardar reglas de protecci칩n para confirmar sus cambios:

    ![Configure staging](images/005/approvers.png)

4. La pr칩xima vez que inserte c칩digo, el flujo de trabajo se detendr치 en el trabajo Implementar en ensayo y esperar치 la aprobaci칩n manual antes de ejecutar los pasos posteriores del trabajo.


